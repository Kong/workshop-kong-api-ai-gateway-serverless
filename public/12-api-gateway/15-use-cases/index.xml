<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Use Cases :: API Management with Kong Konnect</title>
    <link>http://localhost:1313/12-api-gateway/15-use-cases/index.html</link>
    <description>In this chapter we are going to explore the following common use cases we typically implement at the API Gateway Layer.&#xA;Proxy caching API Key with Kong Consumers Rate Limiting using Redis Request Transformer Request Callout OpenID Connect with Keycloak Access Control with Open Policy Agent (OPA) These functionalities are extended by the use of Kong Plugins. You can find a full list of all Kong plugins on the Plugin Hub.</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/12-api-gateway/15-use-cases/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Proxy Caching</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/150-proxy-caching/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/150-proxy-caching/index.html</guid>
      <description>Proxy Caching provides a reverse proxy cache implementation for Kong. It caches response entities based on configurable response code and content type, as well as request method. It can cache per-Consumer or per-API. Cache entities are stored for a configurable period of time, after which subsequent requests to the same resource will re-fetch and re-store the resource. Cache entities can also be forcefully purged via the Admin API prior to their expiration time.</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/151-key-authentication/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/151-key-authentication/index.html</guid>
      <description>To get started with API Authentication, let’s implement a basic Key Authentication mechanism. API Keys are one of the foundamental security mechanisms provided by Konnect. In order to consume an API, the consumer should inject a previously created API Key in the header of the request. The API consumption is allowed if the Gateway recognizes the API Key. Consumers add their API key either in a query string parameter, a header, or a request body to authenticate their requests and consume the application.</description>
    </item>
    <item>
      <title>Response Transformer</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/153-response-transformer/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/153-response-transformer/index.html</guid>
      <description>The Response Transformer plugin modifies the upstream response (e.g. response from the server) before returning it to the client.&#xA;In this section, you will configure the Response Transformer plugin on the Kong Route. Specifically, you will configure Kong Konnect to add a new header “demo: injected-by-kong” before responding to the client.&#xA;Create the Response Transformer Plugin Take the plugins declaration and enable the Response Transformer plugin to the Route.&#xA;cat &gt; response-transformer.yaml &lt;&lt; &#39;EOF&#39; _format_version: &#34;3.0&#34; _konnect: control_plane_name: kong-workshop _info: select_tags: - httpbin-service-route services: - name: httpbin-service host: httpbin.kong.svc.cluster.local port: 8000 routes: - name: response-transformer-route paths: - /response-transformer-route plugins: - name: response-transformer instance_name: response-transformer1 config: add: headers: - demo:injected-by-kong EOF Submit the declaration deck gateway sync --konnect-token $PAT response-transformer.yaml</description>
    </item>
    <item>
      <title>Request Callout</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/154-request-callout/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/154-request-callout/index.html</guid>
      <description>The Request Callout plugin allows you to insert arbitrary API calls before proxying a request to the upstream service.&#xA;In this section, you will configure the Request Callout plugin on the Kong Route. Specifically, you will configure the plugin to do the following:&#xA;Call Wikipedia using the “srseach” header as a parameter. The number of hits found and returned by Wikipeadia is added as a new header to the request. The request is sent to httpbin application which echoes the number of hits. Hit Wikipedia Just to get an idea what the Wikipedia response, send the following request:</description>
    </item>
    <item>
      <title>Rate Limiting Using Redis</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/156-rate-limiting-using-redis/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/156-rate-limiting-using-redis/index.html</guid>
      <description>Kong can rate-limit your traffic without any external dependency. In such a case, Kong stores the request counters in-memory and each Kong node applies the rate-limiting policy independently. There is no synchronization of information being done in this case. But if Redis is available in your cluster, Kong can take advantage of it and synchronize the rate-limit information across multiple Kong nodes and enforce a slightly different rate-limiting policy.&#xA;This section walks through the steps of using Redis for rate-limiting in a multi-node Kong deployment.</description>
    </item>
    <item>
      <title>OpenID Connect</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/157-openidconnect/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/157-openidconnect/index.html</guid>
      <description>For advanced and enterprise class requirements, OpenID Connect (OIDC) is the preferred option to implement API consumer Authentication. OIDC also provides mechanisms to implement Authorization. In fact, when applying OIDC to secure the APIs, we’re delegating the Authentication process to the external Identity Provider entity.&#xA;OpenID Connect is an authentication protocol built on top of OAuth 2.0 and JWT - JSON Web Token to add login and profile information about the identity who is logged in.</description>
    </item>
    <item>
      <title>OPA (Open Policy Agent)</title>
      <link>http://localhost:1313/12-api-gateway/15-use-cases/158-opa-authorization/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/12-api-gateway/15-use-cases/158-opa-authorization/index.html</guid>
      <description>OAuth and OpenID Connect are great and recommended options to implement not just Authentication and Authorization processes. However, there are some use cases where the Authorization policies require a bit of business logic. For example, let’s say we want to prevent our API Consumers from consuming applications, protected by the Gateway, during weekends. In cases like this, one nice possibility is to have a specific layer taking care of the Authorization policies. That’s the main purpose of the Open Policy Agent - OPA engine.</description>
    </item>
  </channel>
</rss>